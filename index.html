<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Love You</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            overflow: hidden;
            background-color: #000 !important;
        }

        body {
            -webkit-font-smoothing: antialiased;
        }

        .webgl {
            position: fixed;
            width: 100vw;
            height: 100vh;
            top: 0;
            left: 0;
            outline: none;
        }

        h1 {
            position: absolute;
            top: 10vh;
            left: 2.5rem;
            right: 1rem;
            text-align: center;
            font-size: max(1rem, 3vh);
        }

        button {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            height: 12vh;
            width: 12vh;
            transform: translateY(2vh);
            right: 0;
            margin: auto;
            -webkit-appearance: none;
            background: transparent;
            color: inherit;
            border: none;
            cursor: pointer;
        }

        svg {
            width: 3.5vh;
        }

        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .modal img {
            max-width: 70vw;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }

        /* Responsive Enhancements */
        @media (max-width: 1024px) {
            h1 { top: 8vh; font-size: 2.5vh; }
            button { height: 10vh; width: 10vh; }
            svg { width: 3vh; }
            .modal img { max-width: 75vw; max-height: 65vh; }
        }

        @media (max-width: 768px) {
            h1 { top: 6vh; left: 1rem; right: 1rem; font-size: 2.2vh; }
            button { height: 9vh; width: 9vh; transform: translateY(1vh); }
            svg { width: 2.8vh; }
            .modal img { max-width: 80vw; max-height: 60vh; }
        }

        @media (max-width: 480px) {
            h1 { top: 4vh; font-size: 1.8vh; }
            button { height: 8vh; width: 8vh; transform: translateY(0); }
            svg { width: 2.5vh; }
            .modal img { max-width: 85vw; max-height: 55vh; }
        }

        @media (orientation: portrait) {
            h1 { top: 12vh; font-size: 2.5vh; }
            button { bottom: 5vh; transform: none; }
            .modal img { max-width: 80vw; max-height: 60vh; }
        }
    </style>
    <script>
        window.console = window.console || function(t) {};
    </script>
    <script>
        if (document.location.search.match(/type=embed/gi)) {
            window.parent.postMessage("resize", "*");
        }
    </script>
</head>
<body translate="no">
    <canvas class="webgl" data-engine="three.js r135"></canvas>
    <button id="play-music" type="button" aria-label="Play music" style="opacity: 1;">
        <svg fill="currentColor" viewBox="0 0 512 512" width="100" title="music">
            <!-- SVG path omitted for brevity -->
        </svg>
    </button>
    <div class="modal" id="imageModal">
        <img id="modalImage" src="" alt="Enlarged Image">
    </div>

    <!-- Shaders (unchanged, included for completeness) -->
    <script type="x-shader/x-vertex" id="vertexShader">
        #define M_PI 3.1415926535897932384626433832795
        uniform float uTime;
        uniform float uSize;
        attribute float aScale;
        attribute vec3 aColor;
        attribute float random;
        attribute float random1;
        attribute float aSpeed;
        varying vec3 vColor;
        varying vec2 vUv;
        void main() {
            float sign = 2.0 * (step(random, 0.5) - .5);
            float t = sign * mod(-uTime * aSpeed * 0.005 + 10.0 * aSpeed * aSpeed, M_PI);
            float a = pow(t, 2.0) * pow((t - sign * M_PI), 2.0);
            float radius = 0.14;
            vec3 myOffset = vec3(t, 1.0, 0.0);
            myOffset = vec3(radius * 16.0 * pow(sin(t), 2.0) * sin(t), radius * (13.0 * cos(t) - 5.0 * cos(2.0 * t) - 2.0 * cos(3.0 * t) - cos(4.0 * t)), .15 * (a * (random1 - .5)) * sin(abs(10.0 * (sin(.2 * uTime + .2 * random))) * t));
            vec3 displacedPosition = myOffset;
            vec4 modelPosition = modelMatrix * vec4(displacedPosition.xyz, 1.0);
            vec4 viewPosition = viewMatrix * modelPosition;
            viewPosition.xyz += position * aScale * uSize * pow(a, .5) * .5;
            gl_Position = projectionMatrix * viewPosition;
            vColor = aColor;
            vUv = uv;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec3 vColor;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec3 color = vColor;
            float strength = distance(uv, vec2(0.5));
            strength *= 2.0;
            strength = 1.0 - strength;
            gl_FragColor = vec4(strength * color, 1.0);
        }
    </script>
    <script type="x-shader/x-vertex" id="vertexShader1">
        #define M_PI 3.1415926535897932384626433832795
        uniform float uTime;
        uniform float uSize;
        attribute float aScale;
        attribute vec3 aColor;
        attribute float phi;
        attribute float random;
        attribute float random1;
        varying vec3 vColor;
        varying vec2 vUv;
        void main() {
            float t = 0.01 * uTime + 12.0;
            float angle = phi;
            t = mod((-uTime + 100.0) * 0.06 * random1 + random * 2.0 * M_PI, 2.0 * M_PI);
            vec3 myOffset = vec3(5.85 * cos(angle * (t)), 2.0 * (t - M_PI), 3.0 * sin(angle * (t) / t));
            vec4 modelPosition = modelMatrix * vec4(myOffset, 1.0);
            vec4 viewPosition = viewMatrix * modelPosition;
            viewPosition.xyz += position * aScale * uSize;
            gl_Position = projectionMatrix * viewPosition;
            vColor = aColor;
            vUv = uv;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader1">
        uniform sampler2D uTex;
        varying vec3 vColor;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec3 color = vColor;
            float strength = distance(uv, vec2(0.5, 0.5));
            strength *= 2.0;
            strength = 1.0 - strength;
            vec3 texture = texture2D(uTex, uv).rgb;
            gl_FragColor = vec4(texture * color * (strength + 0.6), 1.0);
        }
    </script>
    <script type="x-shader/x-vertex" id="vertexShaderMovingImages">
        #define M_PI 3.1415926535897932384626433832795
        uniform float uTime;
        uniform float uSize;
        attribute float aScale;
        attribute vec3 aColor;
        attribute float phi;
        attribute float random;
        attribute float random1;
        varying vec3 vColor;
        varying vec2 vUv;
        void main() {
            float t = uTime * 0.05 + random * 2.0 * M_PI;
            float radius = 2.5 + random1 * 1.5;
            float angle = phi + t;
            float height = sin(t * 0.5 + random) * 1.5;
            vec3 myOffset = vec3(
                radius * cos(angle),
                height,
                radius * sin(angle)
            );
            float scalePulse = 1.0 + 0.5 * sin(t * 2.0 + random1);
            vec4 modelPosition = modelMatrix * vec4(myOffset, 1.0);
            vec4 viewPosition = viewMatrix * modelPosition;
            viewPosition.xyz += position * aScale * uSize * scalePulse;
            gl_Position = projectionMatrix * viewPosition;
            vColor = aColor;
            vUv = uv;
        }
    </script>

    <script src="https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-2c7831bb44f98c1391d6a4ffda0e1fd302503391ca806e7fcc7b9b87197aec26.js"></script>
    <script id="rendered-js" type="module">
        import * as THREE from "https://cdn.skypack.dev/three@0.135.0";
        import { gsap } from "https://cdn.skypack.dev/gsap@3.8.0";
        import { GLTFLoader } from "https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/GLTFLoader";

        class World {
            constructor({
                canvas,
                width,
                height,
                cameraPosition,
                fieldOfView = 75,
                nearPlane = 0.1,
                farPlane = 100
            }) {
                this.parameters = {
                    count: 1500,
                    max: 12.5 * Math.PI,
                    a: 2,
                    c: 4.5
                };
                this.textureLoader = new THREE.TextureLoader();
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x16000a);
                this.clock = new THREE.Clock();
                this.data = 0;
                this.time = { current: 0, t0: 0, t1: 0, t: 0, frequency: 0.0005 };
                this.angle = { x: 0, z: 0 };
                this.width = width || window.innerWidth;
                this.height = height || window.innerHeight;
                this.aspectRatio = this.width / this.height;
                this.fieldOfView = fieldOfView;
                this.camera = new THREE.PerspectiveCamera(
                    fieldOfView,
                    this.aspectRatio,
                    nearPlane,
                    farPlane
                );
                this.camera.position.set(
                    cameraPosition.x,
                    cameraPosition.y,
                    cameraPosition.z
                );
                this.scene.add(this.camera);
                this.renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true
                });
                this.pixelRatio = Math.min(window.devicePixelRatio, 2);
                this.renderer.setPixelRatio(this.pixelRatio);
                this.renderer.setSize(this.width, this.height);
                // Initialize raycaster with a larger threshold for better click detection
                this.raycaster = new THREE.Raycaster();
                this.raycaster.params.Mesh.threshold = 0.7;
                this.mouse = new THREE.Vector2();
                // Modal elements
                this.modal = document.getElementById("imageModal");
                this.modalImage = document.getElementById("modalImage");
                if (!this.modal || !this.modalImage) {
                    console.error("Modal or modal image element not found!");
                }
                console.log("World initialized, canvas:", canvas);
                this.addToScene();
                this.addButton();
                this.addClickHandler();
                this.render();
                this.listenToResize();
                this.listenToMouseMove();
            }

            start() {}

            render() {
                this.renderer.render(this.scene, this.camera);
                this.composer && this.composer.render();
            }

            loop() {
                this.time.elapsed = this.clock.getElapsedTime();
                this.time.delta = Math.min(
                    60,
                    (this.time.current - this.time.elapsed) * 1000
                );
                if (this.analyser && this.isRunning) {
                    this.time.t = this.time.elapsed - this.time.t0 + this.time.t1;
                    this.data = this.analyser.getAverageFrequency();
                    this.data *= this.data / 2000;
                    this.angle.x += this.time.delta * 0.001 * 0.63;
                    this.angle.z += this.time.delta * 0.001 * 0.39;
                    const justFinished = this.isRunning && !this.sound.isPlaying;
                    if (justFinished) {
                        this.time.t1 = this.time.t;
                        this.audioBtn.disabled = false;
                        this.isRunning = false;
                        const tl = gsap.timeline();
                        this.angle.x = 0;
                        this.angle.z = 0;
                        tl.to(this.camera.position, {
                            x: 0,
                            z: 4.5,
                            duration: 4,
                            ease: "expo.in"
                        });
                        tl.to(this.audioBtn, {
                            opacity: () => 1,
                            duration: 1,
                            ease: "power1.out"
                        });
                    } else {
                        this.camera.position.x = Math.sin(this.angle.x) * this.parameters.a;
                        this.camera.position.z = Math.min(
                            Math.max(Math.cos(this.angle.z) * this.parameters.c, 1.75),
                            6.5
                        );
                    }
                }
                this.camera.lookAt(this.scene.position);
                if (this.heartMaterial) {
                    this.heartMaterial.uniforms.uTime.value +=
                        this.time.delta * this.time.frequency * (1 + this.data * 0.2);
                }
                if (this.model) {
                    this.model.rotation.y -= 0.0005 * this.time.delta * (1 + this.data);
                }
                if (this.snowMaterial) {
                    this.snowMaterial.uniforms.uTime.value +=
                        this.time.delta * 0.0004 * (1 + this.data);
                }
                if (this.movingImagesMaterial) {
                    this.movingImagesMaterial.uniforms.uTime.value +=
                        this.time.delta * 0.0004 * (1 + this.data);
                }
                this.render();
                this.time.current = this.time.elapsed;
                requestAnimationFrame(this.loop.bind(this));
            }

            listenToResize() {
                window.addEventListener("resize", () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.camera.aspect = this.width / this.height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.width, this.height);
                    console.log("Window resized:", this.width, this.height);
                });
            }

            listenToMouseMove() {
                window.addEventListener("mousemove", e => {
                    const x = e.clientX;
                    const y = e.clientY;
                    gsap.to(this.camera.position, {
                        x: gsap.utils.mapRange(0, window.innerWidth, 0.2, -0.2, x),
                        y: gsap.utils.mapRange(0, window.innerHeight, 0.2, -0.2, -y)
                    });
                });
            }

            addClickHandler() {
                console.log("Setting up click handler for moving images");
                // Prevent music button clicks from triggering image modal
                this.audioBtn.addEventListener("click", (event) => {
                    event.stopPropagation();
                    console.log("Music button clicked, stopping propagation");
                });

                window.addEventListener("click", (event) => {
                    console.log("Window click detected at:", event.clientX, event.clientY);
                    // Skip if clicking on the modal
                    if (event.target === this.modal || event.target === this.modalImage) {
                        console.log("Modal clicked, ignoring");
                        return;
                    }

                    // Calculate normalized device coordinates
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    console.log("Normalized mouse coords:", this.mouse.x, this.mouse.y);

                    // Update raycaster
                    this.raycaster.setFromCamera(this.mouse, this.camera);

                    // Check intersections with moving images
                    if (this.movingImages) {
                        const intersects = this.raycaster.intersectObject(this.movingImages);
                        if (intersects.length > 0) {
                            console.log("Moving image clicked, instance ID:", intersects[0].instanceId);
                            this.modalImage.src = "./image/nghia.jpg";
                            this.modal.style.display = "flex";
                            console.log("Modal opened with image: ./image/nghia.jpg");
                        } else {
                            console.log("No moving image hit");
                        }
                    } else {
                        console.error("Moving images mesh not found!");
                    }
                });

                // Close modal on click
                this.modal.addEventListener("click", () => {
                    this.modal.style.display = "none";
                    console.log("Modal closed");
                });
            }

            addHeart() {
                this.heartMaterial = new THREE.ShaderMaterial({
                    fragmentShader: document.getElementById("fragmentShader").textContent,
                    vertexShader: document.getElementById("vertexShader").textContent,
                    uniforms: {
                        uTime: { value: 0 },
                        uSize: { value: 0.2 },
                        uTex: {
                            value: this.textureLoader.load(
                                "./image/nghia.jpg",
                                () => console.log("Heart texture loaded"),
                                undefined,
                                (err) => console.error("Error loading heart texture:", err)
                            )
                        }
                    },
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    transparent: true
                });
                const count = this.parameters.count;
                const scales = new Float32Array(count * 1);
                const colors = new Float32Array(count * 3);
                const speeds = new Float32Array(count);
                const randoms = new Float32Array(count);
                const randoms1 = new Float32Array(count);
                const colorChoices = [
                    "white",
                    "red",
                    "pink",
                    "crimson",
                    "hotpink",
                    "green",
                    "aquamarine",
                    "blue"
                ];
                const squareGeometry = new THREE.PlaneGeometry(1, 1);
                this.instancedGeometry = new THREE.InstancedBufferGeometry();
                Object.keys(squareGeometry.attributes).forEach(attr => {
                    this.instancedGeometry.attributes[attr] = squareGeometry.attributes[attr];
                });
                this.instancedGeometry.index = squareGeometry.index;
                this.instancedGeometry.maxInstancedCount = count;
                for (let i = 0; i < count; i++) {
                    const phi = Math.random() * Math.PI * 2;
                    const i3 = 3 * i;
                    randoms[i] = Math.random();
                    randoms1[i] = Math.random();
                    scales[i] = Math.random() * 0.35;
                    const colorIndex = Math.floor(Math.random() * colorChoices.length);
                    const color = new THREE.Color(colorChoices[colorIndex]);
                    colors[i3 + 0] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    speeds[i] = Math.random() * this.parameters.max;
                }
                this.instancedGeometry.setAttribute(
                    "random",
                    new THREE.InstancedBufferAttribute(randoms, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "random1",
                    new THREE.InstancedBufferAttribute(randoms1, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "aScale",
                    new THREE.InstancedBufferAttribute(scales, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "aSpeed",
                    new THREE.InstancedBufferAttribute(speeds, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "aColor",
                    new THREE.InstancedBufferAttribute(colors, 3, false)
                );
                this.heart = new THREE.Mesh(this.instancedGeometry, this.heartMaterial);
                this.scene.add(this.heart);
                console.log("Heart particles added");
            }

            addToScene() {
                this.addModel();
                this.addHeart();
                this.addSnow();
                this.addMovingImages();
            }

            async addModel() {
                try {
                    this.model = await this.loadObj(
                        "https://assets.codepen.io/74321/heart.glb"
                    );
                    if (!this.model) {
                        console.error("Model failed to load: heart.glb");
                        return;
                    }
                    this.model.scale.set(0.5, 0.5, 0.5);
                    this.model.position.set(0, 0, 0);
                    this.model.material = new THREE.MeshMatcapMaterial({
                        matcap: this.textureLoader.load(
                            "./image/nghia.jpg",
                            () => console.log("Matcap texture loaded successfully"),
                            undefined,
                            (err) => console.error("Error loading matcap texture:", err)
                        ),
                        color: "#fff"
                    });
                    this.scene.add(this.model);
                    console.log("Heart model added to scene");
                } catch (err) {
                    console.error("Error in addModel:", err);
                }
            }

            addButton() {
                this.audioBtn = document.querySelector("button");
                this.audioBtn.addEventListener("click", () => {
                    this.audioBtn.disabled = true;
                    if (this.analyser) {
                        this.sound.play();
                        this.time.t0 = this.time.elapsed;
                        this.data = 0;
                        this.isRunning = true;
                        gsap.to(this.audioBtn, {
                            opacity: 0,
                            duration: 1,
                            ease: "power1.out"
                        });
                    } else {
                        this.loadMusic().then(() => {
                            console.log("Music loaded");
                        });
                    }
                });
            }

            loadObj(path) {
                const loader = new GLTFLoader();
                return new Promise((resolve, reject) => {
                    loader.load(
                        path,
                        response => {
                            resolve(response.scene.children[0]);
                            console.log("Heart model loaded");
                        },
                        xhr => {
                            console.log(`Loading model: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
                        },
                        err => {
                            console.error("Error loading model:", err);
                            reject(err);
                        }
                    );
                });
            }

            loadMusic() {
                return new Promise(resolve => {
                    const listener = new THREE.AudioListener();
                    this.camera.add(listener);
                    this.sound = new THREE.Audio(listener);
                    const audioLoader = new THREE.AudioLoader();
                    audioLoader.load(
                        "./mp3/I Do - 911 (Lyrics & Vietsub) - Fall In Luv.mp3",
                        buffer => {
                            this.sound.setBuffer(buffer);
                            this.sound.setLoop(true);
                            this.sound.setVolume(0.5);
                            this.sound.play();
                            this.analyser = new THREE.AudioAnalyser(this.sound, 32);
                            const data = this.analyser.getAverageFrequency();
                            this.isRunning = true;
                            this.t0 = this.time.elapsed;
                            resolve(data);
                            console.log("Music loaded and playing");
                        },
                        progress => {
                            gsap.to(this.audioBtn, {
                                opacity: () => 1 - progress.loaded / progress.total,
                                duration: 1,
                                ease: "power1.out"
                            });
                        },
                        error => {
                            console.error("Error loading music:", error);
                        }
                    );
                });
            }

            addSnow() {
                this.snowMaterial = new THREE.ShaderMaterial({
                    fragmentShader: document.getElementById("fragmentShader1").textContent,
                    vertexShader: document.getElementById("vertexShader1").textContent,
                    uniforms: {
                        uTime: { value: 0 },
                        uSize: { value: 0.3 },
                        uTex: {
                            value: this.textureLoader.load(
                                "./image/nghia.jpg",
                                () => console.log("Snow texture loaded"),
                                undefined,
                                (err) => console.error("Error loading snow texture:", err)
                            )
                        }
                    },
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    transparent: true
                });
                const count = 550;
                const scales = new Float32Array(count * 1);
                const colors = new Float32Array(count * 3);
                const phis = new Float32Array(count);
                const randoms = new Float32Array(count);
                const randoms1 = new Float32Array(count);
                const colorChoices = ["red", "pink", "hotpink", "green", "aquamarine", "blue"];
                const squareGeometry = new THREE.PlaneGeometry(1, 1);
                this.instancedGeometry = new THREE.InstancedBufferGeometry();
                Object.keys(squareGeometry.attributes).forEach(attr => {
                    this.instancedGeometry.attributes[attr] = squareGeometry.attributes[attr];
                });
                this.instancedGeometry.index = squareGeometry.index;
                this.instancedGeometry.maxInstancedCount = count;
                for (let i = 0; i < count; i++) {
                    const phi = (Math.random() - 0.5) * 10;
                    const i3 = 3 * i;
                    phis[i] = phi;
                    randoms[i] = Math.random();
                    randoms1[i] = Math.random();
                    scales[i] = Math.random() * 0.35;
                    const colorIndex = Math.floor(Math.random() * colorChoices.length);
                    const color = new THREE.Color(colorChoices[colorIndex]);
                    colors[i3 + 0] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }
                this.instancedGeometry.setAttribute(
                    "phi",
                    new THREE.InstancedBufferAttribute(phis, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "random",
                    new THREE.InstancedBufferAttribute(randoms, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "random1",
                    new THREE.InstancedBufferAttribute(randoms1, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "aScale",
                    new THREE.InstancedBufferAttribute(scales, 1, false)
                );
                this.instancedGeometry.setAttribute(
                    "aColor",
                    new THREE.InstancedBufferAttribute(colors, 3, false)
                );
                this.snow = new THREE.Mesh(this.instancedGeometry, this.snowMaterial);
                this.scene.add(this.snow);
                console.log("Snow particles added");
            }

            addMovingImages() {
                this.movingImagesMaterial = new THREE.ShaderMaterial({
                    fragmentShader: document.getElementById("fragmentShader1").textContent,
                    vertexShader: document.getElementById("vertexShaderMovingImages").textContent,
                    uniforms: {
                        uTime: { value: 0 },
                        uSize: { value: 1.5 }, // Increased for better click detection
                        uTex: {
                            value: this.textureLoader.load(
                                "./image/nghia.jpg",
                                () => console.log("Moving images texture loaded"),
                                undefined,
                                (err) => console.error("Error loading moving images texture:", err)
                            )
                        }
                    },
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    transparent: true
                });
                const count = 5;
                const scales = new Float32Array(count * 1);
                const colors = new Float32Array(count * 3);
                const phis = new Float32Array(count);
                const randoms = new Float32Array(count);
                const randoms1 = new Float32Array(count);
                const colorChoices = ["red", "pink", "hotpink", "white", "aquamarine"];
                const squareGeometry = new THREE.PlaneGeometry(1.5, 1.5); // Increased geometry size
                this.instancedGeometryMoving = new THREE.InstancedBufferGeometry();
                Object.keys(squareGeometry.attributes).forEach(attr => {
                    this.instancedGeometryMoving.attributes[attr] = squareGeometry.attributes[attr];
                });
                this.instancedGeometryMoving.index = squareGeometry.index;
                this.instancedGeometryMoving.maxInstancedCount = count;
                for (let i = 0; i < count; i++) {
                    const phi = Math.random() * 2.0 * Math.PI;
                    const i3 = 3 * i;
                    phis[i] = phi;
                    randoms[i] = Math.random();
                    randoms1[i] = Math.random();
                    scales[i] = Math.random() * 0.7 + 0.7; // Increased scale range
                    const colorIndex = Math.floor(Math.random() * colorChoices.length);
                    const color = new THREE.Color(colorChoices[colorIndex]);
                    colors[i3 + 0] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }
                this.instancedGeometryMoving.setAttribute(
                    "phi",
                    new THREE.InstancedBufferAttribute(phis, 1, false)
                );
                this.instancedGeometryMoving.setAttribute(
                    "random",
                    new THREE.InstancedBufferAttribute(randoms, 1, false)
                );
                this.instancedGeometryMoving.setAttribute(
                    "random1",
                    new THREE.InstancedBufferAttribute(randoms1, 1, false)
                );
                this.instancedGeometryMoving.setAttribute(
                    "aScale",
                    new THREE.InstancedBufferAttribute(scales, 1, false)
                );
                this.instancedGeometryMoving.setAttribute(
                    "aColor",
                    new THREE.InstancedBufferAttribute(colors, 3, false)
                );
                this.movingImages = new THREE.Mesh(this.instancedGeometryMoving, this.movingImagesMaterial);
                this.scene.add(this.movingImages);
                console.log("Moving images added, count:", count);
            }
        }

        const world = new World({
            canvas: document.querySelector("canvas.webgl"),
            cameraPosition: { x: 0, y: 0, z: 4.5 }
        });
        world.loop();
        console.log("World instance created and loop started");
    </script>
</body>
</html>